#!/usr/bin/env python3
import os
import sys
import subprocess
import hashlib
import json
import urllib.request
import urllib.parse
import urllib.error
import datetime
import shutil
import re

# --- Configuraci칩n y Constantes ---
CONFIG_FILE = "/etc/scanvt/config"
LOG_FILE = "/var/log/scanvt/scan.log"
HASH_CACHE = "/var/cache/scanvt/hashes.txt"
WHITELIST = "/var/cache/scanvt/whitelist.txt"
QUAR_DIR = "/var/quarantine"
FIRST_SCAN_FLAG = "/var/cache/scanvt/.first_scan_done"
CSV_DIR = "/root/scanvt"
TIMESTAMP = datetime.datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
CSV_FILE = f"{CSV_DIR}/scanvt_report_{TIMESTAMP}.csv"

# Valores por defecto
CONFIG = {
    "VT_API_KEY": "",
    "SCAN_DIRS": [],
    "EXCLUDE_DIRS": [".git", "node_modules", "tmp", "cache"], # Default excludes
    "SCAN_DAYS": 7,
    "MAIL_DEST": "root",
    "QUAR_RETENTION_DAYS": 0,
    "VT_THRESHOLD": 1,
    "MAX_FILE_SIZE_MB": 100,
    "ACTION_MODE": "quarantine", # report, quarantine, delete
    # Notificaciones
    "DISCORD_WEBHOOK_URL": "",
    "SLACK_WEBHOOK_URL": "",
    "TELEGRAM_BOT_TOKEN": "",
    "TELEGRAM_CHAT_ID": ""
}

def log(message, level="INFO"):
    timestamp = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    msg = f"[{timestamp}] [{level}] {message}"
    print(msg)
    try:
        with open(LOG_FILE, "a") as f:
            f.write(msg + "\n")
    except Exception as e:
        print(f"Error escribiendo log: {e}")

def parse_bash_config(file_path):
    if not os.path.exists(file_path):
        return
    
    with open(file_path, 'r') as f:
        content = f.read()

    # Regex para arrays bash: VAR=("val1" "val2")
    array_matches = re.findall(r'(\w+)=\((.*?)\)', content, re.DOTALL)
    for key, val_str in array_matches:
        items = re.findall(r'"([^"]*)"', val_str)
        if not items: items = val_str.split()
        CONFIG[key] = items

    # Regex para variables simples: VAR="valor"
    simple_matches = re.findall(r'(\w+)=["\\]?([^"\'\n\(\)]+)["\\]?', content)
    for key, val in simple_matches:
        if key not in CONFIG:
            CONFIG[key] = val

    # Conversiones de tipo
    try: CONFIG["SCAN_DAYS"] = int(CONFIG.get("SCAN_DAYS", 7))
    except: CONFIG["SCAN_DAYS"] = 7
    
    try: CONFIG["QUAR_RETENTION_DAYS"] = int(CONFIG.get("QUAR_RETENTION_DAYS", 0))
    except: CONFIG["QUAR_RETENTION_DAYS"] = 0

    try: CONFIG["VT_THRESHOLD"] = int(CONFIG.get("VT_THRESHOLD", 1))
    except: CONFIG["VT_THRESHOLD"] = 1
    
    try: CONFIG["MAX_FILE_SIZE_MB"] = int(CONFIG.get("MAX_FILE_SIZE_MB", 100))
    except: CONFIG["MAX_FILE_SIZE_MB"] = 100

def setup_env():
    dirs = [os.path.dirname(LOG_FILE), os.path.dirname(HASH_CACHE), QUAR_DIR, CSV_DIR]
    for d in dirs:
        os.makedirs(d, exist_ok=True)
    
    for f in [HASH_CACHE, WHITELIST]:
        if not os.path.exists(f):
            open(f, 'a').close()
            
    if not os.path.exists(CSV_FILE):
        with open(CSV_FILE, 'w') as f:
            f.write("Archivo,Hash,Detecciones,Estado,Fecha\n")

def get_file_hash(filepath):
    sha256_hash = hashlib.sha256()
    try:
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()
    except Exception as e:
        log(f"Error calculando hash de {filepath}: {e}", "ERROR")
        return None

def check_list(file_path, search_hash):
    if not os.path.exists(file_path):
        return False
    with open(file_path, 'r') as f:
        return search_hash in f.read()

def append_to_list(file_path, text):
    with open(file_path, 'a') as f:
        f.write(text + "\n")

def scan_files(files_to_scan):
    if not files_to_scan: return {}
    infected_files = {}
    
    # 1. Intentar clamdscan
    cmd = ["clamdscan", "--no-summary", "--fdpass", "-"]
    try:
        proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdout, stderr = proc.communicate(input="\n".join(files_to_scan))
        if proc.returncode == 2: raise Exception("clamdscan error")
    except:
        # 2. Fallback clamscan
        log("Usando clamscan fallback (lento)...", "INFO")
        cmd = ["clamscan", "--no-summary", "-"]
        proc = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdout, stderr = proc.communicate(input="\n".join(files_to_scan))

    for line in stdout.splitlines():
        if " FOUND" in line:
            parts = line.split(":")
            if len(parts) >= 2:
                file_path = parts[0].strip()
                virus_name = parts[1].replace(" FOUND", "").strip()
                infected_files[file_path] = virus_name
    return infected_files

def check_virustotal(file_hash, api_key):
    if not api_key: return -1
    url = f"https://www.virustotal.com/api/v3/files/{file_hash}"
    headers = {"x-apikey": api_key}
    req = urllib.request.Request(url, headers=headers)
    try:
        with urllib.request.urlopen(req) as response:
            data = json.loads(response.read().decode())
            return data['data']['attributes']['last_analysis_stats']['malicious']
    except urllib.error.HTTPError as e:
        if e.code == 404: return 0 
        log(f"Error VT API: {e}", "ERROR")
        return -1
    except Exception:
        return -1

# --- Notificaciones ---
def send_discord(message):
    url = CONFIG.get("DISCORD_WEBHOOK_URL")
    if not url: return
    data = json.dumps({"content": message}).encode()
    try:
        req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'})
        urllib.request.urlopen(req)
    except Exception as e: log(f"Error Discord: {e}", "ERROR")

def send_slack(message):
    url = CONFIG.get("SLACK_WEBHOOK_URL")
    if not url: return
    data = json.dumps({"text": message}).encode()
    try:
        req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'})
        urllib.request.urlopen(req)
    except Exception as e: log(f"Error Slack: {e}", "ERROR")

def send_telegram(message):
    token = CONFIG.get("TELEGRAM_BOT_TOKEN")
    chat_id = CONFIG.get("TELEGRAM_CHAT_ID")
    if not token or not chat_id: return
    url = f"https://api.telegram.org/bot{token}/sendMessage"
    data = urllib.parse.urlencode({"chat_id": chat_id, "text": message}).encode()
    try:
        urllib.request.urlopen(url, data=data)
    except Exception as e: log(f"Error Telegram: {e}", "ERROR")

def notify(subject, body):
    # Email
    if CONFIG["MAIL_DEST"] and "@" in CONFIG["MAIL_DEST"]:
        try:
            proc = subprocess.Popen(['mail', '-s', subject, CONFIG["MAIL_DEST"]], stdin=subprocess.PIPE, text=True)
            proc.communicate(input=body)
        except: pass
    
    # Modern Channels
    full_msg = f"**{subject}**\n{body}"
    send_discord(full_msg)
    send_slack(full_msg)
    send_telegram(full_msg)

def should_exclude(path):
    # Check exclude dirs
    for excl in CONFIG["EXCLUDE_DIRS"]:
        if f"/{excl}/" in path or path.endswith(f"/{excl}"):
            return True
    
    # Check file size
    try:
        size_mb = os.path.getsize(path) / (1024 * 1024)
        if size_mb > CONFIG["MAX_FILE_SIZE_MB"]:
            return True
    except: pass
    
    return False

def main():
    setup_env()
    parse_bash_config(CONFIG_FILE)
    
    if not CONFIG["SCAN_DIRS"]:
        log("No hay directorios configurados.", "ERROR")
        sys.exit(1)

    log(f">>> Escaneo iniciado. Modo: {CONFIG['ACTION_MODE']}")
    
    # 1. Identificar archivos
    files_to_scan = []
    is_first_scan = not os.path.exists(FIRST_SCAN_FLAG)
    
    for directory in CONFIG["SCAN_DIRS"]:
        if not os.path.exists(directory): continue

        cmd = ["find", directory, "-type", "f"]
        if not is_first_scan:
            cmd.extend(["-mtime", f"-{CONFIG['SCAN_DAYS']}"])
        
        try:
            result = subprocess.run(cmd, stdout=subprocess.PIPE, text=True, check=True)
            raw_files = result.stdout.splitlines()
            
            # Filtrar en Python (Exclusiones y Tama침o)
            for f in raw_files:
                if not should_exclude(f):
                    files_to_scan.append(f)
                    
        except Exception as e: log(f"Error find {directory}: {e}", "ERROR")

    if not files_to_scan:
        log(">>> Fin (Sin archivos)")
        return

    log(f"Analizando {len(files_to_scan)} archivos...")
    infected_files = scan_files(files_to_scan)
    
    # 2. Procesar
    for file_path, virus_name in infected_files.items():
        if not os.path.exists(file_path): continue # Puede haber sido movido
        
        log(f"[ALERTA] Detectado: {file_path} ({virus_name})")
        file_hash = get_file_hash(file_path)
        
        if check_list(WHITELIST, file_hash):
            log("Whitelist. Ignorando.")
            append_to_list(CSV_FILE, f"{file_path},{file_hash},0,Whitelist,{datetime.datetime.now()}")
            continue
            
        if check_list(HASH_CACHE, file_hash):
            log("Hash cacheado (ya revisado antes).")
            # Si se quisiera re-verificar, eliminar칤amos esta l칤nea
            append_to_list(CSV_FILE, f"{file_path},{file_hash},?,Cache,{datetime.datetime.now()}")
            continue
            
        append_to_list(HASH_CACHE, file_hash)

        # L칩gica de Acci칩n / Cuarentena Temporal para an치lisis seguro
        action = CONFIG["ACTION_MODE"].lower()
        temp_quarantine_path = os.path.join(QUAR_DIR, os.path.basename(file_path))
        original_path = file_path
        
        # Si NO es 'report', movemos preventivamente
        if action != "report":
            try:
                shutil.move(file_path, temp_quarantine_path)
                file_path = temp_quarantine_path # Actualizar referencia para operaciones futuras
            except Exception as e: 
                log(f"Fallo al mover a cuarentena: {e}", "ERROR")
                # Si falla mover, seguimos analizando en el lugar original si es posible
        
        # Consultar VT
        positives = check_virustotal(file_hash, CONFIG["VT_API_KEY"])
        threshold = CONFIG["VT_THRESHOLD"]

        is_malware = positives >= threshold
        
        if is_malware:
            log(f"[MALWARE] Confirmado ({positives}/{threshold} motores).")
            append_to_list(CSV_FILE, f"{original_path},{file_hash},{positives},Malware,{datetime.datetime.now()}")
            
            body = (f"Archivo: {original_path}\n"
                    f"Virus: {virus_name}\n"
                    f"Motores VT: {positives}\n"
                    f"Acci칩n: {action}")
            notify(f"游뚿 Malware: {os.path.basename(original_path)}", body)

            if action == "delete":
                try:
                    if os.path.exists(file_path): os.remove(file_path)
                    log(f"Archivo eliminado: {file_path}")
                except Exception as e: log(f"Error eliminando: {e}", "ERROR")
            
            elif action == "report":
                log("Modo Reporte: Archivo se mantiene en sitio original.")
            
            # Si es 'quarantine', ya est치 movido, as칤 que no hacemos nada m치s.

        else:
            # Falso Positivo o Bajo Threshold
            log(f"[FALSO POSITIVO] {positives} motores. Restaurando/Ignorando.")
            append_to_list(CSV_FILE, f"{original_path},{file_hash},{positives},Falso Positivo,{datetime.datetime.now()}")
            append_to_list(WHITELIST, file_hash)
            
            # Si lo hab칤amos movido, hay que devolverlo
            if action != "report" and os.path.exists(temp_quarantine_path):
                try:
                    shutil.move(temp_quarantine_path, original_path)
                    log("Archivo restaurado.")
                except Exception as e: log(f"Error restaurando: {e}", "ERROR")
            
            # Notificar FP restaurado? Opcional, puede generar ruido.
            # notify("丘멆잺 Falso Positivo Restaurado", f"{original_path} ({positives} hits)")

    # Limpieza
    retention = CONFIG["QUAR_RETENTION_DAYS"]
    if retention > 0:
        try:
            cmd = ["find", QUAR_DIR, "-type", "f", "-mtime", f"+{retention}", "-delete"]
            subprocess.run(cmd)
        except: pass

    if not os.path.exists(FIRST_SCAN_FLAG):
        open(FIRST_SCAN_FLAG, 'a').close()
        
    log(">>> Fin")

if __name__ == "__main__":
    main()
